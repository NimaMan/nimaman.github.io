<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mean Absorbing Time of a Two dimensional Random Walk - Nima Manaf, Ph.D.</title>
    <meta name="description" content="Mean Absorbing Time of a Two dimensional Random Walk">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Prism for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <!-- KaTeX for math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --primary-light: #3b82f6;
            --secondary: #64748b;
            --accent: #f59e0b;
            --success: #10b981;
            --gray-50: #f8fafc;
            --gray-100: #f1f5f9;
            --gray-200: #e2e8f0;
            --gray-300: #cbd5e1;
            --gray-400: #94a3b8;
            --gray-500: #64748b;
            --gray-600: #475569;
            --gray-700: #334155;
            --gray-800: #1e293b;
            --gray-900: #0f172a;
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-primary);
            color: var(--gray-800);
            line-height: 1.6;
            background: #ffffff;
        }

        /* Navigation */
        .nav {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--gray-200);
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--gray-900);
            text-decoration: none;
        }

        .nav-menu {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-link {
            color: var(--gray-600);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .nav-link:hover {
            color: var(--primary);
        }

        /* Article Header */
        .article-header {
            background: linear-gradient(135deg, var(--gray-50) 0%, var(--gray-100) 100%);
            padding: 8rem 0 4rem;
            margin-top: 4rem;
        }

        .article-header-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 0 2rem;
            text-align: center;
        }

        .article-date {
            color: var(--gray-500);
            font-size: 0.875rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .article-title {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 700;
            line-height: 1.2;
            color: var(--gray-900);
            margin: 1rem 0 1.5rem;
        }

        .article-meta {
            display: flex;
            gap: 2rem;
            justify-content: center;
            align-items: center;
            color: var(--gray-600);
            font-size: 0.875rem;
        }

        /* Article Content */
        .article-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 4rem 2rem;
        }

        .article-content h1,
        .article-content h2,
        .article-content h3,
        .article-content h4,
        .article-content h5,
        .article-content h6 {
            color: var(--gray-900);
            margin: 2rem 0 1rem;
            font-weight: 600;
            line-height: 1.3;
        }

        .article-content h2 {
            font-size: 1.875rem;
            margin-top: 3rem;
        }

        .article-content h3 {
            font-size: 1.5rem;
        }

        .article-content p {
            margin-bottom: 1.5rem;
            color: var(--gray-700);
            line-height: 1.8;
        }

        .article-content ul,
        .article-content ol {
            margin: 0 0 2rem 2rem;
            color: var(--gray-700);
        }

        .article-content li {
            margin-bottom: 0.5rem;
            line-height: 1.8;
        }

        .article-content blockquote {
            border-left: 4px solid var(--primary);
            padding-left: 1.5rem;
            margin: 2rem 0;
            font-style: italic;
            color: var(--gray-600);
        }

        .article-content img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            margin: 2rem auto;
            display: block;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .article-content code {
            font-family: var(--font-mono);
            font-size: 0.875em;
            background: var(--gray-100);
            padding: 0.2em 0.4em;
            border-radius: 0.25rem;
            color: var(--gray-800);
        }

        .article-content pre {
            margin: 2rem 0;
            border-radius: 0.5rem;
            overflow-x: auto;
        }

        .article-content pre code {
            background: none;
            padding: 0;
            font-size: 0.9rem;
        }

        /* Math */
        .katex-display {
            margin: 2rem 0;
            overflow-x: auto;
        }

        /* Back to Posts */
        .back-link {
            max-width: 800px;
            margin: 0 auto;
            padding: 0 2rem 4rem;
        }

        .back-link a {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
            transition: gap 0.3s ease;
        }

        .back-link a:hover {
            gap: 0.75rem;
        }

        /* Footer */
        .footer {
            background: var(--gray-50);
            border-top: 1px solid var(--gray-200);
            padding: 3rem 0;
            text-align: center;
            color: var(--gray-600);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .nav-menu {
                display: none;
            }
            
            .article-content {
                padding: 2rem 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-container">
            <a href="/" class="nav-logo">Nima Manaf, Ph.D.</a>
            <ul class="nav-menu">
                <li><a href="/" class="nav-link">Home</a></li>
                <li><a href="/posts/" class="nav-link">Articles</a></li>
                <li><a href="/cv/" class="nav-link">CV</a></li>
            </ul>
        </div>
    </nav>

    <!-- Article Header -->
    <header class="article-header">
        <div class="article-header-content">
            <time class="article-date">September 3, 2022</time>
            <h1 class="article-title">Mean Absorbing Time of a Two dimensional Random Walk</h1>
            <div class="article-meta">
                <span><i class="far fa-clock"></i> 8 min read</span>
                <span><i class="far fa-folder"></i> Mathematics</span>
            </div>
        </div>
    </header>

    <!-- Back Link -->
    <div class="back-link">
        <a href="/posts/">
            <i class="fas fa-arrow-left"></i>
            Back to all articles
        </a>
    </div>

    <!-- Article Content -->
    <article class="article-content">
        <h1>Question</h1>
        <p>An ant leaves its anthill in order to forage for food. It moves with the speed of 1 unit per time step, but it doesn't know where to go, therefore every time step it moves randomly 1 unit directly north, south, east or west with equal probability.</p>

        <ol>
            <li><p>If the food is located on east-west lines 2 units to the north and 2 units to the south, as well as on north-south lines 2 units to the east and 2 units to the west from the anthill, how long will it take the ant to reach it on average?</p></li>
            <li><p>What is the average time the ant will reach food if it is located only on a diagonal line passing through (1, 0) and (0, 1) points?</p></li>
            <li><p>Can you write a program that comes up with an estimate of average time to find food for any closed boundary around the anthill?</p></li>
        </ol>

        <h1>Solution</h1>
        <p>I am not sure whether the food is located on the set of points in \(\{(0, 2), (0, -2), (2, 0), (-2, 0)\}\) or horizontal and vertical lines passing through these points. If the question is asking for the mean time to reach the lines passing through these points the answer is pretty straightforward. It can be found using the code for solving question number three which solves a set of linear equations for the mean time to get absorbed into states outside a given boundary. Otherwise, I solve this question in the following way.</p>

        <p>Let \(s_t = (i_t, j_t)\) denote the distance of the ant on the east-west and south-north directions at time t where \(t \in \{0, 1, 2, 3, \dots\} \) denotes the number of time steps passed since the ant has started moving. Notice that the movement of the ant has a Markovian property as the position of the ant only depends on its latest position. Mathematically speaking:</p>

        $$P \left(s_{t+1}=(i_{t+1}, j_{t+1}) | s_{t}, s_{t-1}, s_{0}\right) = P \left(s_{t+1}=(i_{t+1}, j_{t+1}) | s_{t}\right).$$

        <p>Markovian property states that regardless of the history of the movements of the ant the mean number of steps to enter a given state is only dependent on the current state or position of the ant. I will use this property in calculating the time it takes for the ant to reach the food on average starting from a given position.</p>

        <h2>Q1</h2>
        <p>Let \( Z^{A} = \{(0, 2), (0, -2), (2, 0), (-2, 0) \} \) be the set of coordinates where the food is located and \( V(s) = \mathop{\mathrm{\mathbb{E}}}\left[\min\{n: s_n \in Z^{A}|s_0=s\} \right], \) be the first time that the ant enters a state in \((Z^{A}) \) (the time that the ant reaches the food) starting from the state \( s = (i, j)\). In order to find the mean number of steps to reach the food, I condition on the current state of the ant. Assume that the ant is currently in state \((i, j) \notin Z^{A}\). The mean number of steps for the ant to enter a state in \(Z^{A} \) is equal to taking one step in a random direction plus the mean number of steps to enter \(Z^{A}\) from the new state. Since we move in each direction randomly with probability \(\frac{1}{4}\) we can write:</p>

        $$V((i, j)) = 1 + \frac{1}{4} V((i+1, j)) + \frac{1}{4} V((i-1, j)) + \frac{1}{4} V((i, j+1)) + \frac{1}{4}V((i, j-1)).$$

        <p>We are interested in finding \(V((0, 0))\) to calculate the mean number of steps for the ant to reach a food. We need to solve the two-dimensional recursive equations given in the above Equation for \(i, j \in \{ -\infty, \dots, +\infty\}\) to calculate \(V((0, 0))\). Solving these equations maybe cumbersome. Hence, I will partition the state space into a set of points that have the same distance to the closest point in \(Z^A\) to simplify the problem. Define \((i^N, j^N)\) as the nearest point in \(Z^A\) to position \((i, j)\)</p>

        $$(i^N, j^N) = \mathop{\mathrm{arg\,min}}_{(u, v) \in Z^{A}} |u - i| + |v - j|,$$

        <p>where \(|i|, |j| \geq 1\). I cluster the states into the following sets:</p>

        \begin{align*}
        Z^{0} &= \{(0, 0)\}, \\
        Z^{-1} &= \{(1, 0), (-1, 0), (0, 1), (0, -1)\}, \\
        Z^{-2} &= \{(1, 1), (1, -1), (-1, 1), (-1, -1)\}, \\
        Z^{d} &= \{(i, j): |i - i^N| + |j - j^N| = d \}, d\geq 1.
        \end{align*}

        <p>One-step transition from each of these sets results in moving to the neighboring sets. Following the Markovian property and symmetric nature of the problem \(V^\gamma = V((i, j)), \ \forall (i, j) \in Z^\gamma\) where \(\gamma \in \{-2, -1, 0, 1, 2, \dots \}\). The mean number of steps to enter \(Z^A\) starting from a point in \(Z^\gamma\) can be written as</p>

        $$\begin{align}
        V^{-2} &= 1 + \frac{1}{2}V^{-1} + \frac{1}{2}V^{1}, \nonumber \\
        V^{-1} &= 1 + \frac{1}{2}V^{-2} + \frac{1}{4}V^{0}, \nonumber \\
        V^{0} &= 1 + V^{-1}, \nonumber \\
        V^{1} &= 1 + \frac{1}{2}V^{-2} + \frac{1}{2}V^{2},\nonumber \\
        V^{d} &= 1 + \frac{1}{2}V^{d-1} + \frac{1}{2}V^{d+1}, \ \forall d \in \{2, 3, \dots\}.
        \end{align}$$

        <p>After some algebra these equations can be re-written in the following form:</p>

        $$\begin{align}
        V^{-1} &= \frac{2}{3}V^{-2} + \frac{5}{3}, \nonumber\\
        V^{-2} &= \frac{3}{4}V^{1} + \frac{5+6}{4}, \nonumber\\
        V^{1} &= \frac{4}{5}V^{2} + \frac{5+6+8}{5}, \nonumber\\
        V^{n} &= \frac{n+3}{n+4}V^{n+1} + \frac{5+\sum\limits_{j=0}^{n} (6+2(n-j))} {n+4}.
        \end{align}$$

        <p>The summation term in the above equation can be further simplified as</p>

        $$\alpha (n) = 5+\sum\limits_{j=0}^{n} (6+2(n-j)) = n^2 +7n + 11.$$

        <p>Re-writing \(V^1\) as a function of \(V^n\) we get</p>

        $$V^1 = \frac{4}{n+3} V^n + 4\sum\limits_{j=1}^{n-1} \frac{\alpha(j)}{(j+3)(j+4)} =  \frac{4}{n+3} V^n + 4\sum\limits_{j=1}^{n-1} \frac{\alpha(j)}{\alpha(j)+1}.$$

        <p>The summation \(\sum\limits_{j=1}^{n-1} \frac{\alpha(j)}{\alpha(j)+1}\) in the above equation diverges to \(\infty\) as we let \(n\to\infty\). That is to say that the average number of steps to enter an absorbing state in \(Z^A\) starting from a point in \(Z^1\), is the summation of infinity and the average number of steps to enter \(Z^A\) starting from a point in \(Z^\infty\) divided by \((n+3)\). The result of this summation is equal to infinity. Hence, starting from the anthill the mean number of steps to find a food is infinity.</p>

        <h2>Question 2</h2>
        <p>I take a similar approach to the question one to find the mean number of steps to reach the food located on the line \(i+j = 1\) starting from \((0, 0)\). I cluster the states below the line into the parallel line that are distance \(d\) away from \(i+j = 1\).</p>

        $$Z^{d} =  \{(i, j): i + j = 1 - d \}, \ \text{for } d \in \{1, 2, 3, \dots\}$$

        <p>Starting from a state in \(Z^d\) with probability \(\frac{1}{2}\) we move to a state in \(Z^{d+1}\) and with probability \(\frac{1}{2}\) to a state in \(Z^{d-1}\). Similar to the previous question, letting \(V^d\) be the mean number of steps to reach a food starting from a point in \(Z^d\), we can write</p>

        $$\begin{align}
        V^{1} &=  1 + \frac{1}{2}V^{2}, \nonumber\\
        V^{d} &=  1 + \frac{1}{2}V^{d-1} + \frac{1}{2}V^{d+1}, \ \forall d \in \{2, 3, \dots\}.
        \end{align}$$

        <p>Re-writing \(V^{1}\) as a function of \(V^n\) we get</p>

        $$V^1 = n-1 + \frac{1}{n} V^n.$$

        <p>This equation means that the average number of steps to enter any point on line \(i+j = 1\) starting from a point on set \(Z^1\) is the sum of infinity and mean number of time to hit the line starting from a point in \(Z^\infty\) divided by \(n\). Hence, the mean number of points to reach the food starting from \((0, 0)\) is infinity.</p>

        <h2>Question 3</h2>
        <p>The mean number of steps to reach the food outside the boundary given in question number three is 14. The code below can be used to find the number of steps to reach the food using simulation and analytic methods. The number of steps to reach the food can be generated either serially or in parallel using the simulation.</p>

        <p>It is also possible to find the exact solution by extracting the states \((i, j)\) inside the boundary, generating the probability transition matrix of the transient states, and solving the set of equations.</p>

        <pre><code class="language-python">import numpy as np


class RandomWalK2D():
    def __init__(self, ):
        self.p = 1/4
        self.max_number_steps = int(1e8)
        self.init_state = (0, 0)  # (x, y)
        self.states_trajectory = [self.init_state]
        self.absorbing_states = {(2, 2), (2, -2), (-2, 2), (-2, -2)}
    
    @staticmethod
    def puzzle_1_boundry_func(state):
        
        return ((abs(state[0]) < 2) and (abs(state[1]) < 2))
    
    @staticmethod
    def puzzle_3_boundry_func(state):
        
        return ((state[0]-0.25)/3)**2 + ((state[1]-0.25)/4)**2 < 1
    
    def one_step_transition(self, current_state):
        rnd = np.random.random()
        new_state = [None, None]
        if rnd < self.p:
            new_state[0] = current_state[0] + 1
            new_state[1] = current_state[1]
        elif (rnd >= self.p) & (rnd < 2*self.p):
            new_state[0] = current_state[0] - 1
            new_state[1] = current_state[1]
        elif (rnd >= 2*self.p) & (rnd < 3 * self.p):
            new_state[0] = current_state[0]
            new_state[1] = current_state[1] + 1
        else:
            new_state[0] = current_state[0]
            new_state[1] = current_state[1] - 1

        return tuple(new_state)

    def get_num_steps_to_absorbing_states_in_set(self, track_states=False,
                                                 init_state=(0, 0)):
        num_steps = 0
        current_state = init_state
        while current_state not in self.absorbing_states:
            current_state = self.one_step_transition(current_state)
            if track_states:
                self.states_trajectory.append(current_state)
            if num_steps > self.max_number_steps:
                return num_steps
            num_steps += 1
            
        return num_steps

    
    def get_num_steps_to_absorbing_states_on_linear_line(self, p1=(1, 0),
                                                         p2=(0, 1), 
                                                         track_states=False,
                                                         init_state=(0, 0)):
        line_slope = (p1[1]- p2[1])/(p1[0]- p2[0])
        line_intercept = p1[1] - p1[0] * line_slope
        
        num_steps = 0
        current_state = init_state
        while (current_state[1] - current_state[0]*line_slope) != line_intercept:
            current_state = self.one_step_transition(current_state)
            if track_states:
                self.states_trajectory.append(current_state)
            if num_steps > self.max_number_steps:
                return num_steps
            num_steps += 1
        return num_steps     

    def get_num_steps_to_absorbing_states_outside_boundry(self, 
                                                            track_states=False,
                                                            init_state=(0, 0)):
        
        num_steps = 0
        current_state = init_state
        while self.puzzle_3_boundry_func(current_state):
            current_state = self.one_step_transition(current_state)
            if track_states:
                self.states_trajectory.append(current_state)
            if num_steps > self.max_number_steps:
                return num_steps
            num_steps += 1
            
        return num_steps
    
     def get_neighboring_states(self, current_state):
        i, j = current_state
        
        return ((i-1, j), (i+1, j), (i, j-1), (i, j+1))
        
    def get_states_inside_baoundry(self, boundry_func):
        current_state = (0, 0)
        is_explored = []
        to_explore = [current_state]
        states_in_boundry = {(0, 0)}
        while True:
            new_states = self.get_neighboring_states(current_state)
            for state in new_states:
                if boundry_func(state):
                    states_in_boundry.add(state)
                    if state not in is_explored:
                        to_explore.append(state)
                        
            to_explore.remove(current_state)
            is_explored.append(current_state)
            if len(to_explore)>=1:
                current_state = to_explore[-1]
            else:
                break 
            
        return states_in_boundry
    
    def get_states_in_boundry_transition_matrix(self, boundry_func):
        states_in_boundry = list(self.get_states_inside_baoundry(boundry_func))
        
        probability_transition = np.zeros((len(states_in_boundry), 
                                           len(states_in_boundry)))
        
        for state_idx, state in enumerate(states_in_boundry):
            neighbor_states = self.get_neighboring_states(state)
            p = 0
            for ns in neighbor_states:
                if ns in states_in_boundry:
                    ns_idx = states_in_boundry.index(ns)
                    probability_transition[state_idx, ns_idx] = 0.25
                    
        return probability_transition, states_in_boundry
    
    def get_mean_time_to_boundry_func_analytic(self, boundry_func):
        p, s = self.get_states_in_boundry_transition_matrix(boundry_func)
        n = p.shape[0]
        origin_idx = s.index((0, 0))
        return np.linalg.inv(np.eye(n) - p)[origin_idx].sum()
    
    def run_experiments_parallel(self, experiment_func, num_samples, 
                                 mp_num_processors=4):
        import multiprocessing as mp 
        pool = mp.Pool(processes=mp_num_processors)
        num_steps_samples = [
            pool.apply_async(experiment_func)
            for idx in range(num_samples)
            ]
        
        num_steps_samples = [result.get() for result in num_steps_samples]
            
        return num_steps_samples
    
    def run_experiments_serial(self, experiment_func, num_samples):
        num_steps_samples = []
        for _ in range(num_samples):
            num_steps = experiment_func()
            num_steps_samples.append(num_steps)
        
        return num_steps_samples
    

if __name__ == "__main__":
    
    rw = RandomWalK2D()
    boundry_func_1 = rw.puzzle_1_boundry_func
    puzzle_1_mean_time = rw.get_mean_time_to_boundry_func_analytic(boundry_func)
    
    """
    experiment_func = rw.get_num_steps_to_absorbing_states_outside_boundry
    num_samples = int(1e6)
    
    samples = rw.run_experiments_parallel(experiment_func, num_samples, mp_num_processors=4)
    mean_number_of_steps = np.mean(samples)
    boundry_func_3 = rw.puzzle_3_boundry_func
    puzzle_3_mean_time = rw.get_mean_time_to_boundry_func_analytic(boundry_func_3)
    assert  np.isclose(mean_number_of_steps, puzzle_3_mean_time, rtol=1e-3)
    """</code></pre>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <p>&copy; 2024 Nima Manaf, Ph.D. All rights reserved.</p>
    </footer>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
</body>
</html>